{"ast":null,"code":"import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n/**\n * @function importAll\n * @param {any} r - Require Context.\n * @returns {string} - File paths.\n */\n\n\nvar importAll = function importAll(r) {\n  return r.keys().map(r);\n};\n/**\n * @function importAllImages\n * @param {string} directory - The complete directory/folder path.\n * @param {regex} extensions - file extension filter.\n * @returns {string}\n */\n\n\nvar importAllImages = function importAllImages(directory) {\n  var extensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /\\.(jpg|jpeg|png|svg)$/;\n  return importAll(require.context(directory, false, extensions));\n};\n/**\n * @function hasProperty\n * @param {string} property - The property to check for in the given object.\n * @param {object} object - The object in which to check for above given property.\n * @returns {any}\n */\n\n\nvar hasProperty = function hasProperty(property, object) {\n  try {\n    return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && !Array.isArray(object) && object.hasOwnProperty(property);\n  } catch (e) {\n    console.warn(e.message, e);\n    return false;\n  }\n};\n/**\n * @function isObject\n * @param {object} object - Object to check if is an object.\n * @returns {boolean}\n */\n\n\nvar isObject = function isObject(object) {\n  try {\n    return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && !Array.isArray(object);\n  } catch (e) {\n    console.warn(e.message, e);\n    return false;\n  }\n};\n\nvar Particle = function Particle(canvas, options) {\n  classCallCheck(this, Particle);\n\n  _initialiseProps.call(this);\n\n  var shape = options.shape,\n      color = options.color,\n      image = options.image,\n      size = options.size,\n      precision = options.precision,\n      x = options.x,\n      y = options.y,\n      debugOptions = options.debugOptions;\n  this.canvas = canvas;\n  this.ctx = canvas.getContext('2d');\n  this.shape = shape || 'circle';\n  this.color = color || '#F20000';\n  this.precision = precision || 2;\n  this.size = this.parseSize(size) || this.parseSize(+Math.random().toFixed(this.precision));\n  this.x = x || +Math.random().toFixed(this.precision);\n  this.y = y || +Math.random().toFixed(this.precision);\n  this.imageOptions = image || undefined;\n  this.image = new Image();\n  this.debug = debugOptions || {\n    enabled: false\n  }; // Errors\n\n  if (image !== undefined && !hasProperty('src', image)) {\n    throw new Error(\"Image object must have 'src' property.\");\n  }\n\n  if (!(hasProperty('width', this.size) && hasProperty('height', this.size)) && !hasProperty('radius', this.size)) {\n    throw new Error(\"Size object must have either 'width' AND 'height' OR 'radius' property.\");\n  }\n\n  if (this.debug.enabled) {\n    if (hasProperty('attachAllParticles', this.debug) && this.debug.attachAllParticles) {\n      window.Particles = window.Particles || [];\n      window.Particles.push(this);\n    }\n\n    window.Particle = this;\n  }\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this = this;\n\n  this.parseSize = function (size) {\n    var trueSize = size;\n\n    if ((typeof size === 'undefined' ? 'undefined' : _typeof(size)) !== 'object') {\n      trueSize = _this.shape === 'circle' ? {\n        radius: size\n      } : {\n        width: size,\n        height: size\n      };\n    }\n\n    return trueSize;\n  };\n\n  this.draw = function () {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.x;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.y;\n    var size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _this.size;\n    var posX = _this.x = x;\n    var posY = _this.y = y;\n    var rSize = _this.size = size;\n\n    if (_this.imageOptions) {\n      _this.image.src = _this.imageOptions.src;\n\n      _this.ctx.drawImage(_this.image, _this.x, _this.y, _this.getSize('x'), _this.getSize('y'));\n    } else {\n      switch (_this.shape) {\n        case 'rectangle':\n        case 'rect':\n        case 'square':\n          var width = rSize.width,\n              height = rSize.height;\n\n          if (_this.shape === 'square') {\n            height = width;\n          }\n\n          _this.drawRectangle(posX, posY, width, height);\n\n          break;\n\n        case 'circle':\n        default:\n          var radius = rSize.radius;\n\n          _this.drawCircle(posX, posY, radius);\n\n          break;\n      }\n    }\n  };\n\n  this.drawCircle = function (x, y, radius) {\n    _this.ctx.beginPath();\n\n    _this.ctx.arc(x, y, radius, 0, Math.PI * 2);\n\n    _this.ctx.fillStyle = _this.color;\n\n    _this.ctx.fill();\n  };\n\n  this.drawRectangle = function (x, y, width, height) {\n    _this.ctx.fillStyle = _this.color;\n\n    _this.ctx.fillRect(x, y, width, height);\n  };\n\n  this.drawImage = function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    console.log(args);\n\n    _this.ctx.drawImage.apply(_this.ctx, args);\n  };\n\n  this.getSize = function (axis) {\n    if (axis === 'x') {\n      return _this.size.width || _this.size.radius;\n    } else if (axis === 'y') {\n      return _this.size.height || _this.size.radius;\n    }\n  };\n};\n\nvar Particles =\n/**\n * @param canvas The html canvas element\n *\n * Example Particle Options:\n * @param options = {\n *   maxParticles: 0,\n *   colors: ['red', 'green', '#ff1000'],\n *   shapes: ['square', 'circle', 'rectangle', { type: 'image', src: '/path/to/image' }],\n *   size: 0.00,\n *   minSize: 0.00,\n *   maxSize: 0.00,\n *   velocity: 0.00,\n *   minSpeed: 0.00,\n *   maxSpeed: 0.00,\n *   alpha: 0.7\n * }\n *\n */\nfunction Particles(canvas, options) {\n  classCallCheck(this, Particles);\n\n  _initialiseProps$1.call(this);\n\n  var maxParticles = options.maxParticles,\n      backgroundColor = options.backgroundColor,\n      colors = options.colors,\n      shapes = options.shapes,\n      size = options.size,\n      minSize = options.minSize,\n      maxSize = options.maxSize,\n      minSpeed = options.minSpeed,\n      maxSpeed = options.maxSpeed,\n      alpha = options.alpha,\n      frameRate = options.frameRate,\n      duration = options.duration,\n      precision = options.precision,\n      debugOptions = options.debugOptions;\n  this.particles = [];\n  this.canvas = canvas;\n  this.ctx = canvas.getContext('2d');\n  this.precision = precision || 2;\n  this.canvas.style.backgroundColor = backgroundColor || '#f1f1f1';\n  this.maxParticles = maxParticles === null || maxParticles === undefined ? 50 : maxParticles;\n  this.colors = Array.isArray(colors) ? colors : [colors] || ['red', 'green', 'yellow'];\n  this.shapes = Array.isArray(shapes) ? shapes : [shapes] || ['circle', 'square', 'rectangle'];\n  this.size = size;\n  this.maxSize = +parseFloat(maxSize).toFixed(this.precision) || 20;\n  this.minSize = +parseFloat(minSize).toFixed(this.precision) || 10;\n  this.maxSpeed = +parseFloat(maxSpeed).toFixed(this.precision) || 0.09;\n  this.minSpeed = +parseFloat(minSpeed).toFixed(this.precision) || 0.05;\n  this.alpha = alpha || 0.5;\n  this.frameRate = frameRate || 0;\n  this.frameInterval = 1000 / this.frameRate;\n  this.duration = duration || 0;\n  this.debugOptions = debugOptions || {\n    showFrameRate: false\n  };\n  this.debug = {\n    frames: 0,\n    start: null,\n    frameRate: null\n  };\n  this.particleOptions = options;\n  this.paused = false;\n  this.createParticles();\n};\n\nvar _initialiseProps$1 = function _initialiseProps() {\n  var _this = this;\n\n  this.createParticles = function () {\n    var _particles = [].concat(toConsumableArray(Array(_this.maxParticles)));\n\n    if (_this.maxParticles === 0 && _typeof(_this.shapes[0]) === 'object') {\n      _particles = _this.shapes;\n    }\n    /**\n     * @param {string|null|object} item - Shape object or string or null.\n     */\n\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = _particles.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _ref = _step.value;\n\n        var _ref2 = slicedToArray(_ref, 2);\n\n        var i = _ref2[0];\n        var item = _ref2[1];\n        var particleOptions = Object.assign(_this.particleOptions, _this.buildParticleOptions(item));\n        var particle = new Particle(_this.canvas, particleOptions);\n\n        _this.attachParticleAnimationConfig(particle, item);\n\n        _this.positionCorrection(particle, i);\n\n        _this.particles = !Array.isArray(_this.particles) ? [] : _this.particles;\n\n        _this.particles.push(particle);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  };\n\n  this.buildParticleOptions = function () {\n    var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var particleOptions = {};\n\n    if (item !== null && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {\n      particleOptions = Object.assign({}, item);\n\n      if (hasProperty('type', item) && item.type !== 'image') {\n        particleOptions.shape = item.type;\n      } else if (hasProperty('type', item) && item.type === 'image') {\n        particleOptions.shape = 'square';\n\n        if (hasProperty('src', item)) {\n          particleOptions.image = {\n            src: item.src\n          };\n        } else {\n          throw new Error('Shape of type `image` must have property `src`.');\n        }\n      } else {\n        particleOptions.shape = typeof item === 'string' ? item : _this.getRandomShape();\n      }\n    }\n\n    particleOptions.shape = particleOptions.shape || _this.shape || _this.getRandomShape();\n    particleOptions.size = particleOptions.size || _this.size || _this.genRandomSize(particleOptions.shape);\n\n    if (_typeof(particleOptions.size) !== 'object') {\n      particleOptions.size = _this.parseSize(particleOptions.size, particleOptions);\n    }\n\n    particleOptions.color = particleOptions.color || _this.getRandomColor();\n    particleOptions.x = particleOptions.x || _this.getRandomCoordinate('x', undefined, undefined, undefined, particleOptions);\n    particleOptions.y = particleOptions.y || _this.getRandomCoordinate('y', undefined, undefined, undefined, particleOptions);\n    return particleOptions;\n  };\n\n  this.attachParticleAnimationConfig = function (particle, item) {\n    if (hasProperty('animate', particle)) {\n      return particle;\n    }\n\n    particle.animate = {};\n    particle.animate.bounds = {};\n\n    if (particle.shape === 'circle') {\n      particle.animate.bounds.minX = particle.getSize('x');\n      particle.animate.bounds.minY = particle.getSize('y');\n    } else {\n      particle.animate.bounds.minX = particle.animate.bounds.minY = 0;\n    }\n\n    particle.animate.bounds.maxX = _this.canvas.width - particle.getSize('x');\n    particle.animate.bounds.maxY = _this.canvas.height - particle.getSize('y');\n    particle.animate.xSpace = particle.x + particle.animate.bounds.minX;\n    particle.animate.ySpace = particle.y + particle.animate.bounds.minY;\n    particle.animate.xSpace = _this.getDistance(particle, 'x');\n    particle.animate.ySpace = _this.getDistance(particle, 'y');\n\n    if (hasProperty('from', item)) {\n      particle.animate.to = {\n        x: particle.x,\n        y: particle.y,\n        size: particle.size,\n        duration: item.to.duration\n      };\n      particle.x = item.from.x;\n      particle.y = item.from.y;\n      particle.size = hasProperty('size', item.from) ? item.from.size : particle.size;\n    }\n\n    if (hasProperty('to', item)) {\n      particle.animate.to = item.to;\n    }\n\n    if (hasProperty('to', particle.animate)) {\n      var duration = hasProperty('duration', particle.animate.to) ? particle.animate.to.duration : _this.duration;\n      particle.animate.speed.x = (particle.animate.to.x - particle.x) / duration;\n      particle.animate.speed.y = (particle.animate.to.y - particle.y) / duration;\n      particle.animate.direction = {\n        x: particle.animate.to.x - particle.x > 0 ? -1 : 1,\n        y: particle.animate.to.y - particle.y > 0 ? -1 : 1\n      };\n    } else {\n      var direction = [1, -1];\n      particle.animate.speed = {};\n      particle.animate.speed.x = particle.animate.speed.y = _this.getRandomFloat(_this.minSpeed, _this.maxSpeed);\n      particle.animate.direction = {\n        x: direction[_this.getRandomInt(0, 1)],\n        y: direction[_this.getRandomInt(0, 1)]\n      };\n    }\n  };\n\n  this.getDistance = function (particle, axis) {\n    return particle[axis] + particle.getSize(axis);\n  };\n\n  this.positionCorrection = function (particle, i) {\n    var padding = 5;\n\n    var _particles = _this.particles.splice(i);\n\n    var _newParticles = _particles.map(function (_particle) {\n      if (_particle.x < particle.animate.xSpace || _particle.animate.xSpace > particle.x) {\n        var totalXSpace = particle.animate.xSpace + padding + _particle.animate.xSpace;\n\n        if (totalXSpace < _this.canvas.width) {\n          _particle.x = particle.animate.xSpace + padding;\n        } else {\n          _particle.x = particle.x - padding;\n        }\n      }\n\n      if (_particle.y < particle.animate.ySpace || _particle.animate.ySpace > particle.y) {\n        var totalYSpace = particle.animate.ySpace + padding + _particle.animate.ySpace;\n\n        if (totalYSpace < _this.canvas.height) {\n          _particle.y = particle.animate.ySpace + padding;\n        } else {\n          _particle.y = particle.y - padding;\n        }\n      }\n\n      return _particle;\n    });\n\n    _this.particles.concat(_newParticles);\n  };\n\n  this.animate = function () {\n    _this.interval = window.requestAnimationFrame(_this.animate);\n\n    _this.draw(); // Debug\n\n\n    if (_this.debugOptions.showFrameRate) {\n      _this.debug.start = _this.debug.start || performance.now();\n      var now = performance.now();\n      _this.debug.frames++;\n      var delta = now - _this.debug.start;\n\n      if (delta > 1000) {\n        _this.debug.frameRate = _this.debug.frames;\n        _this.debug.frames = 0;\n        _this.debug.start = performance.now();\n      }\n    }\n  };\n\n  this.draw = function () {\n    _this.ctx.clearRect(0, 0, _this.canvas.width, _this.canvas.height);\n\n    _this.ctx.globalAlpha = _this.alpha;\n\n    _this.particles.map(function (particle) {\n      if (hasProperty('to', particle.animate)) {\n        _this.incrementTo(particle);\n      } else {\n        _this.incrementor(particle);\n      }\n\n      particle.draw();\n\n      _this.ctx.restore();\n\n      return particle;\n    });\n  };\n\n  this.clear = function () {\n    window.cancelAnimationFrame(_this.interval);\n  };\n\n  this.incrementTo = function (particle) {// TODO: add logic\n  };\n\n  this.incrementor = function (particle) {\n    var directions = ['x', 'y', 'xy'];\n\n    var direction = directions[_this.getRandomInt(0, directions.length - 1)];\n\n    switch (direction) {\n      case 'x':\n        _this.safeIncrement(particle, 'x');\n\n        break;\n\n      case 'y':\n        _this.safeIncrement(particle, 'y');\n\n        break;\n\n      case 'xy':\n        _this.safeIncrement(particle, 'x');\n\n        _this.safeIncrement(particle, 'y');\n\n        break;\n    }\n  };\n\n  this.safeIncrement = function (particle, axis) {\n    var projection = particle[axis] + particle.animate.direction[axis] * particle.animate.speed[axis];\n\n    if (projection > particle.animate.bounds['max' + axis.toUpperCase()] || projection < particle.animate.bounds['min' + axis.toUpperCase()]) {\n      particle.animate.direction[axis] = -1 * particle.animate.direction[axis];\n      projection = particle[axis] + particle.animate.direction[axis] * particle.animate.speed[axis];\n    }\n\n    particle[axis] = projection;\n  };\n\n  this.getRandomShape = function () {\n    return _this.shapes[_this.getRandomInt(0, _this.shapes.length - 1)];\n  };\n\n  this.getRandomColor = function () {\n    return _this.colors[_this.getRandomInt(0, _this.colors.length - 1)];\n  };\n\n  this.getRandomCoordinate = function (axis, from, to, fixed, ctx) {\n    from = from || 0;\n    fixed = fixed || 2;\n\n    if (axis === 'x') {\n      // canvas width - size to keep particles within canvas boundary\n      to = to || _this.canvas.width - _this.getSize('x', ctx);\n    } else if (axis === 'y') {\n      // canvas width - size to keep particles within canvas boundary\n      to = to || _this.canvas.height - _this.getSize('y', ctx);\n    } else {\n      throw new Error('Illegal Axis!');\n    }\n\n    var x = _this.getRandomInt(from, to);\n\n    return x;\n  };\n\n  this.genRandomSize = function () {\n    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'circle';\n    var size = void 0;\n\n    if (type === 'circle') {\n      size = {\n        radius: _this.getRandomInt(_this.minSize, _this.maxSize)\n      };\n    } else {\n      size = {\n        width: _this.getRandomInt(_this.minSize, _this.maxSize),\n        height: _this.getRandomInt(_this.minSize, _this.maxSize)\n      };\n\n      if (type === 'square') {\n        size.width = size.height;\n      }\n    }\n\n    return size;\n  };\n\n  this.getRandomFloat = function (min, max) {\n    return Math.random() * (max - min) + min;\n  };\n\n  this.getRandomInt = function (min, max) {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n  };\n\n  this.getSize = function (axis, particle) {\n    var object = (typeof particle === 'undefined' ? 'undefined' : _typeof(particle)) === 'object' ? particle : _this;\n    var dimension = axis === 'x' ? 'width' : 'height';\n\n    if (particle.shape === 'circle') {\n      dimension = 'radius';\n    }\n\n    return parseInt(object.size[dimension]);\n  };\n\n  this.parseSize = function (size, ctx) {\n    var trueSize = size;\n    var obj = ctx || _this;\n\n    if ((typeof size === 'undefined' ? 'undefined' : _typeof(size)) !== 'object') {\n      trueSize = obj.shape === 'circle' ? {\n        radius: size\n      } : {\n        width: size,\n        height: size\n      };\n    }\n\n    return trueSize;\n  };\n};\n\nvar aux = function aux(props) {\n  return props.children;\n};\n\nvar sizePropType = PropTypes.oneOf([{\n  width: PropTypes.number.isRequired,\n  height: PropTypes.number\n}, {\n  radius: PropTypes.number.isRequired\n}, PropTypes.number]);\nvar shapePropType = PropTypes.shape({\n  type: PropTypes.oneOf(['image', 'rectangle', 'square', 'circle']).isRequired,\n  src: PropTypes.string,\n  size: sizePropType,\n  color: PropTypes.string,\n  to: PropTypes.shape({\n    x: PropTypes.number,\n    y: PropTypes.number,\n    size: sizePropType,\n    duration: PropTypes.number,\n    speed: PropTypes.number\n  })\n});\n\nvar Canvas = function (_Component) {\n  inherits(Canvas, _Component);\n\n  function Canvas(props) {\n    classCallCheck(this, Canvas);\n\n    var _this = possibleConstructorReturn(this, (Canvas.__proto__ || Object.getPrototypeOf(Canvas)).call(this, props));\n\n    _initialiseProps$2.call(_this);\n\n    _this.handler = props.handler || Particles;\n    return _this;\n  }\n\n  createClass(Canvas, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      window.addEventListener('resize', function () {\n        if (_this2.canvas) {\n          _this2.canvasSizing(_this2.canvas);\n        }\n      });\n      this.canvasSizing(this.canvas);\n\n      if (this.particles !== null && _typeof(this.particles.debug) === 'object') {\n        this.debugInterval = setInterval(function () {\n          window.test = _this2.particles.debug;\n          var debug = Object.assign({}, _this2.particles.debug);\n\n          _this2.setState({\n            debug: debug\n          });\n        }, 1000);\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      var _this3 = this;\n\n      window.removeEventListener('resize', function () {\n        _this3.canvasSizing(_this3.canvas);\n      });\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this4 = this;\n\n      var debugElement = null;\n\n      if (this.state.debug !== null && _typeof(this.state.debug) === 'object' && this.state.debug.frameRate !== null) {\n        this.canvas.parentElement.style.position = 'relative';\n        debugElement = React.createElement('div', {\n          style: {\n            position: 'absolute',\n            top: 0,\n            right: 0,\n            fontSize: '14px',\n            padding: '10px',\n            color: 'white',\n            backgroundColor: 'rgba(0,0,0,0.7)'\n          }\n        }, this.state.debug.frameRate, ' ', React.createElement('i', null, 'fps'));\n      }\n\n      return React.createElement(aux, null, React.createElement('canvas', {\n        className: this.props.className,\n        style: this.props.style,\n        ref: function ref(canvas) {\n          _this4.canvas = canvas;\n        }\n      }), debugElement);\n    }\n  }]);\n  return Canvas;\n}(Component);\n\nCanvas.propTypes = {\n  options: PropTypes.shape({\n    maxParticles: PropTypes.number,\n    color: PropTypes.string,\n    colors: PropTypes.arrayOf(PropTypes.string),\n    shape: PropTypes.oneOfType([shapePropType, PropTypes.string]),\n    shapes: PropTypes.arrayOf(PropTypes.oneOfType([shapePropType, PropTypes.string])),\n    minSize: PropTypes.number,\n    maxSize: PropTypes.number,\n    size: PropTypes.number,\n    minSpeed: PropTypes.number,\n    maxSpeed: PropTypes.number,\n    alpha: PropTypes.number,\n    frameRate: PropTypes.number,\n    duration: PropTypes.number,\n    precision: PropTypes.number,\n    debugOptions: PropTypes.shape({\n      enabled: PropTypes.bool.isRequired,\n      attachAllParticles: PropTypes.bool,\n      attachSingleParticles: PropTypes.bool\n    })\n  }),\n  handler: function handler(props, propName, componentName) {\n    if (props.handler === null || props.handler === undefined) {\n      return null;\n    }\n\n    if (!props.handler.hasOwnProperty('animate') && typeof props.handler.animate !== 'function') {\n      return new Error(propName + ' must have an \\'animate\\' method in ' + componentName + '.');\n    }\n\n    if (!props.handler.hasOwnProperty('draw') && typeof props.handler.draw !== 'function') {\n      return new Error(propName + ' must have an \\'draw\\' method in ' + componentName + '.');\n    }\n\n    return null;\n  },\n  className: PropTypes.string,\n  style: PropTypes.object\n};\n\nvar _initialiseProps$2 = function _initialiseProps() {\n  var _this5 = this;\n\n  this.state = {\n    debug: null\n  };\n  this.handler = null;\n  this.debugInterval = null;\n\n  this.canvasSizing = function (canvas) {\n    window.can = canvas;\n    var wWidth = canvas.parentElement.clientWidth;\n    var wHeight = canvas.parentElement.clientHeight;\n    var scale = window.devicePixelRatio;\n    canvas.style.width = wWidth + 'px';\n    canvas.style.height = wHeight + 'px';\n    canvas.width = scale * wWidth;\n    canvas.height = scale * wHeight;\n\n    if (_this5.particles !== null && _typeof(_this5.particles) === 'object') {\n      _this5.particles.clear();\n\n      delete _this5.particles;\n    }\n\n    _this5.animate();\n  };\n\n  this.animate = function () {\n    var options = _this5.props.options;\n    var Handler = _this5.handler;\n    _this5.particles = new Handler(_this5.canvas, options);\n\n    _this5.particles.animate();\n  };\n};\n\nexport { Canvas, Particle, Particles, importAllImages, importAll, hasProperty, isObject };","map":{"version":3,"sources":["../src/utils/index.js","../src/components/Canvas/Particle.js","../src/components/Canvas/Particles.js","../src/components/Aux/Aux.js","../src/components/Canvas/Canvas.js"],"names":["importAll","r","importAllImages","extensions","require","hasProperty","Array","object","e","isObject","Particle","shape","color","image","size","precision","x","y","debugOptions","options","canvas","Math","enabled","window","parseSize","trueSize","radius","width","height","draw","posX","posY","rSize","drawCircle","drawRectangle","drawImage","args","getSize","axis","Particles","maxParticles","backgroundColor","colors","shapes","minSize","maxSize","minSpeed","maxSpeed","alpha","frameRate","duration","parseFloat","showFrameRate","createParticles","_particles","babelHelpers.typeof","i","item","particleOptions","Object","particle","buildParticleOptions","src","attachParticleAnimationConfig","direction","getDistance","positionCorrection","padding","_newParticles","_particle","totalXSpace","totalYSpace","animate","performance","now","delta","clear","incrementTo","incrementor","directions","safeIncrement","projection","getRandomShape","getRandomColor","getRandomCoordinate","from","fixed","to","genRandomSize","type","getRandomFloat","max","getRandomInt","dimension","parseInt","obj","ctx","aux","props","sizePropType","PropTypes","shapePropType","number","Canvas","Component","propTypes","bool","propName","state","handler","debugInterval","debug","canvasSizing","wWidth","wHeight","scale","Handler","debugElement"],"mappings":"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","sourcesContent":["/**\n * @function importAll\n * @param {any} r - Require Context.\n * @returns {string} - File paths.\n */\nexport const importAll = (r) => {\n    return r.keys().map(r);\n};\n\n/**\n * @function importAllImages\n * @param {string} directory - The complete directory/folder path.\n * @param {regex} extensions - file extension filter.\n * @returns {string}\n */\nexport const importAllImages = (directory, extensions = /\\.(jpg|jpeg|png|svg)$/) => {\n    return importAll(require.context(directory, false, extensions));\n};\n\n/**\n * @function hasProperty\n * @param {string} property - The property to check for in the given object.\n * @param {object} object - The object in which to check for above given property.\n * @returns {any}\n */\nexport const hasProperty = (property, object) => {\n    try {\n        return (typeof object === 'object') && !Array.isArray(object) && object.hasOwnProperty(property);\n    } catch (e) {\n        console.warn(e.message, e);\n        return false;\n    }\n};\n\n/**\n * @function isObject\n * @param {object} object - Object to check if is an object.\n * @returns {boolean}\n */\nexport const isObject = (object) => {\n    try {\n        return (typeof object === 'object') && !Array.isArray(object);\n    } catch (e) {\n        console.warn(e.message, e);\n        return false;\n    }\n};\n","import { hasProperty } from '../../utils';\n\nexport default class Particle {\n    constructor(canvas, options) {\n        const {\n            shape,\n            color,\n            image,\n            size,\n            precision,\n            x,\n            y,\n            debugOptions\n        } = options;\n\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        this.shape = shape || 'circle';\n        this.color = color || '#F20000';\n        this.precision = precision || 2;\n        this.size = this.parseSize(size) || this.parseSize(+Math.random().toFixed(this.precision));\n        this.x = x || +Math.random().toFixed(this.precision);\n        this.y = y || +Math.random().toFixed(this.precision);\n        this.imageOptions = image || undefined;\n        this.image = new Image();\n        this.debug = debugOptions || { enabled: false };\n\n        // Errors\n        if (image !== undefined && !hasProperty('src', image)) {\n            throw new Error(\"Image object must have 'src' property.\");\n        }\n\n        if (!(hasProperty('width', this.size) && hasProperty('height', this.size)) && !hasProperty('radius', this.size)) {\n            throw new Error(\"Size object must have either 'width' AND 'height' OR 'radius' property.\");\n        }\n\n        if (this.debug.enabled) {\n            if (hasProperty('attachAllParticles', this.debug) && this.debug.attachAllParticles) {\n                window.Particles = window.Particles || [];\n                window.Particles.push(this);\n            }\n            window.Particle = this;\n        }\n    }\n\n    parseSize = (size) => {\n        let trueSize = size;\n        if (typeof size !== 'object') {\n            trueSize = this.shape === 'circle' ? { radius: size } : { width: size, height: size };\n        }\n        return trueSize;\n    }\n\n    draw = (x = this.x, y = this.y, size = this.size) => {\n        const posX = this.x = x;\n        const posY = this.y = y;\n        const rSize = this.size = size;\n\n        if (this.imageOptions) {\n            this.image.src = this.imageOptions.src;\n            this.ctx.drawImage(this.image, this.x, this.y, this.getSize('x'), this.getSize('y'));\n        } else {\n            switch (this.shape) {\n                case 'rectangle':\n                case 'rect':\n                case 'square':\n                    let { width, height } = rSize;\n                    if (this.shape === 'square') {\n                        height = width;\n                    }\n                    this.drawRectangle(posX, posY, width, height);\n                    break;\n\n                case 'circle':\n                default:\n                    const { radius } = rSize;\n                    this.drawCircle(posX, posY, radius);\n                    break;\n            }\n        }\n    }\n\n    drawCircle = (x, y, radius) => {\n        this.ctx.beginPath();\n        this.ctx.arc(x, y, radius, 0, Math.PI * 2);\n        this.ctx.fillStyle = this.color;\n        this.ctx.fill();\n    }\n\n    drawRectangle = (x, y, width, height) => {\n        this.ctx.fillStyle = this.color;\n        this.ctx.fillRect(x, y, width, height);\n    }\n\n    drawImage = (...args) => {\n        console.log(args);\n        this.ctx.drawImage.apply(this.ctx, args);\n    }\n\n    getSize = (axis) => {\n        if (axis === 'x') {\n            return this.size.width || this.size.radius;\n        } else if (axis === 'y') {\n            return this.size.height || this.size.radius;\n        }\n    }\n}\n","import Particle from './Particle';\nimport { hasProperty } from '../../utils';\n\nexport default class Particles {\n    /**\n     * @param canvas The html canvas element\n     *\n     * Example Particle Options:\n     * @param options = {\n     *   maxParticles: 0,\n     *   colors: ['red', 'green', '#ff1000'],\n     *   shapes: ['square', 'circle', 'rectangle', { type: 'image', src: '/path/to/image' }],\n     *   size: 0.00,\n     *   minSize: 0.00,\n     *   maxSize: 0.00,\n     *   velocity: 0.00,\n     *   minSpeed: 0.00,\n     *   maxSpeed: 0.00,\n     *   alpha: 0.7\n     * }\n     *\n     */\n    constructor(canvas, options) {\n        const {\n            maxParticles,\n            backgroundColor,\n            colors,\n            shapes,\n            size,\n            minSize,\n            maxSize,\n            minSpeed,\n            maxSpeed,\n            alpha,\n            frameRate,\n            duration,\n            precision,\n            debugOptions\n        } = options;\n\n        this.particles = [];\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        this.precision = precision || 2;\n        this.canvas.style.backgroundColor = backgroundColor || '#f1f1f1';\n\n        this.maxParticles = maxParticles === null || maxParticles === undefined ? 50 : maxParticles;\n        this.colors = Array.isArray(colors) ? colors : [colors] || ['red', 'green', 'yellow'];\n        this.shapes = Array.isArray(shapes) ? shapes : [shapes] || ['circle', 'square', 'rectangle'];\n        this.size = size;\n        this.maxSize = +parseFloat(maxSize).toFixed(this.precision) || 20;\n        this.minSize = +parseFloat(minSize).toFixed(this.precision) || 10;\n        this.maxSpeed = +parseFloat(maxSpeed).toFixed(this.precision) || 0.09;\n        this.minSpeed = +parseFloat(minSpeed).toFixed(this.precision) || 0.05;\n        this.alpha = alpha || 0.5;\n        this.frameRate = frameRate || 0;\n        this.frameInterval = 1000 / this.frameRate;\n        this.duration = duration || 0;\n        this.debugOptions = debugOptions || { showFrameRate: false };\n        this.debug = {\n            frames: 0,\n            start: null,\n            frameRate: null\n        };\n        this.particleOptions = options;\n        this.paused = false;\n        this.createParticles();\n    }\n\n    createParticles = () => {\n        let _particles = [...Array(this.maxParticles)];\n        if (this.maxParticles === 0 && typeof this.shapes[0] === 'object') {\n            _particles = this.shapes;\n        }\n\n        /**\n         * @param {string|null|object} item - Shape object or string or null.\n         */\n        for (const [i, item] of _particles.entries()) {\n            const particleOptions = Object.assign(this.particleOptions, this.buildParticleOptions(item));\n            const particle = new Particle(this.canvas, particleOptions);\n            this.attachParticleAnimationConfig(particle, item);\n            this.positionCorrection(particle, i);\n\n            this.particles = !Array.isArray(this.particles) ? [] : this.particles;\n            this.particles.push(particle);\n        }\n    }\n\n    buildParticleOptions = (item = null) => {\n        let particleOptions = {};\n        if (item !== null && typeof item === 'object') {\n            particleOptions = Object.assign({}, item);\n            if (hasProperty('type', item) && item.type !== 'image') {\n                particleOptions.shape = item.type;\n            } else if (hasProperty('type', item) && item.type === 'image') {\n                particleOptions.shape = 'square';\n\n                if (hasProperty('src', item)) {\n                    particleOptions.image = {\n                        src: item.src\n                    };\n                } else {\n                    throw new Error('Shape of type `image` must have property `src`.');\n                }\n            } else {\n                particleOptions.shape = typeof item === 'string' ? item : this.getRandomShape();\n            }\n        }\n\n        particleOptions.shape = particleOptions.shape || this.shape || this.getRandomShape();\n        particleOptions.size = particleOptions.size || this.size || this.genRandomSize(particleOptions.shape);\n\n        if (typeof particleOptions.size !== 'object') {\n            particleOptions.size = this.parseSize(particleOptions.size, particleOptions);\n        }\n\n        particleOptions.color = particleOptions.color || this.getRandomColor();\n        particleOptions.x = particleOptions.x || this.getRandomCoordinate('x', undefined, undefined, undefined, particleOptions);\n        particleOptions.y = particleOptions.y || this.getRandomCoordinate('y', undefined, undefined, undefined, particleOptions);\n        return particleOptions;\n    }\n\n    attachParticleAnimationConfig = (particle, item) => {\n        if (hasProperty('animate', particle)) {\n            return particle;\n        }\n\n        particle.animate = {};\n        particle.animate.bounds = {};\n        if (particle.shape === 'circle') {\n            particle.animate.bounds.minX = particle.getSize('x');\n            particle.animate.bounds.minY = particle.getSize('y');\n        } else {\n            particle.animate.bounds.minX = particle.animate.bounds.minY = 0;\n        }\n\n        particle.animate.bounds.maxX = this.canvas.width - particle.getSize('x');\n        particle.animate.bounds.maxY = this.canvas.height - particle.getSize('y');\n        particle.animate.xSpace = particle.x + particle.animate.bounds.minX;\n        particle.animate.ySpace = particle.y + particle.animate.bounds.minY;\n\n        particle.animate.xSpace = this.getDistance(particle, 'x');\n        particle.animate.ySpace = this.getDistance(particle, 'y');\n\n        if (hasProperty('from', item)) {\n            particle.animate.to = {x: particle.x, y: particle.y, size: particle.size, duration: item.to.duration};\n            particle.x = item.from.x;\n            particle.y = item.from.y;\n            particle.size = hasProperty('size', item.from) ? item.from.size : particle.size;\n        }\n        if (hasProperty('to', item)) {\n            particle.animate.to = item.to;\n        }\n\n        if (hasProperty('to', particle.animate)) {\n            let duration = hasProperty('duration', particle.animate.to) ? particle.animate.to.duration : this.duration;\n            particle.animate.speed.x = (particle.animate.to.x - particle.x) / duration;\n            particle.animate.speed.y = (particle.animate.to.y - particle.y) / duration;\n            particle.animate.direction = {\n                x: (particle.animate.to.x - particle.x) > 0 ? -1 : 1,\n                y: (particle.animate.to.y - particle.y) > 0 ? -1 : 1\n            };\n        } else {\n            const direction = [1, -1];\n            particle.animate.speed = {};\n            particle.animate.speed.x = particle.animate.speed.y = this.getRandomFloat(this.minSpeed, this.maxSpeed);\n            particle.animate.direction = {\n                x: direction[this.getRandomInt(0, 1)],\n                y: direction[this.getRandomInt(0, 1)]\n            };\n        }\n    }\n\n    getDistance = (particle, axis) => {\n        return particle[axis] + particle.getSize(axis);\n    }\n\n    positionCorrection = (particle, i) => {\n        const padding = 5;\n        let _particles = this.particles.splice(i);\n\n        let _newParticles = _particles.map((_particle) => {\n            if (_particle.x < particle.animate.xSpace || _particle.animate.xSpace > particle.x) {\n                const totalXSpace = particle.animate.xSpace + padding + _particle.animate.xSpace;\n                if (totalXSpace < this.canvas.width) {\n                    _particle.x = particle.animate.xSpace + padding;\n                } else {\n                    _particle.x = particle.x - padding;\n                }\n            }\n\n            if (_particle.y < particle.animate.ySpace || _particle.animate.ySpace > particle.y) {\n                const totalYSpace = particle.animate.ySpace + padding + _particle.animate.ySpace;\n                if (totalYSpace < this.canvas.height) {\n                    _particle.y = particle.animate.ySpace + padding;\n                } else {\n                    _particle.y = particle.y - padding;\n                }\n            }\n\n            return _particle;\n        });\n\n        this.particles.concat(_newParticles);\n    }\n\n    animate = () => {\n        this.interval = window.requestAnimationFrame(this.animate);\n        this.draw();\n\n        // Debug\n        if (this.debugOptions.showFrameRate) {\n            this.debug.start = this.debug.start || performance.now();\n            let now = performance.now();\n            this.debug.frames++;\n            const delta = now - this.debug.start;\n            if (delta > 1000) {\n                this.debug.frameRate = this.debug.frames;\n                this.debug.frames = 0;\n                this.debug.start = performance.now();\n            }\n        }\n    }\n\n    draw = () => {\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        this.ctx.globalAlpha = this.alpha;\n\n        this.particles.map((particle) => {\n            if (hasProperty('to', particle.animate)) {\n                this.incrementTo(particle);\n            } else {\n                this.incrementor(particle);\n            }\n\n            particle.draw();\n            this.ctx.restore();\n\n            return particle;\n        });\n    }\n\n    clear = () => {\n        window.cancelAnimationFrame(this.interval);\n    }\n\n    incrementTo = (particle) => {\n        // TODO: add logic\n    }\n\n    incrementor = (particle) => {\n        const directions = ['x', 'y', 'xy'];\n        let direction = directions[this.getRandomInt(0, directions.length - 1)];\n\n        switch (direction) {\n            case 'x':\n                this.safeIncrement(particle, 'x');\n                break;\n\n            case 'y':\n                this.safeIncrement(particle, 'y');\n                break;\n\n            case 'xy':\n                this.safeIncrement(particle, 'x');\n                this.safeIncrement(particle, 'y');\n                break;\n        }\n    }\n\n    safeIncrement = (particle, axis) => {\n        let projection = particle[axis] + (particle.animate.direction[axis] * particle.animate.speed[axis]);\n\n        if (projection > particle.animate.bounds['max' + axis.toUpperCase()] || projection < particle.animate.bounds['min' + axis.toUpperCase()]) {\n            particle.animate.direction[axis] = -1 * particle.animate.direction[axis];\n            projection = particle[axis] + (particle.animate.direction[axis] * particle.animate.speed[axis]);\n        }\n\n        particle[axis] = projection;\n    }\n\n    getRandomShape = () => {\n        return this.shapes[this.getRandomInt(0, this.shapes.length - 1)];\n    }\n\n    getRandomColor = () => {\n        return this.colors[this.getRandomInt(0, this.colors.length - 1)];\n    }\n\n    getRandomCoordinate = (axis, from, to, fixed, ctx) => {\n        from = from || 0;\n        fixed = fixed || 2;\n\n        if (axis === 'x') {\n            // canvas width - size to keep particles within canvas boundary\n            to = to || this.canvas.width - this.getSize('x', ctx);\n        } else if (axis === 'y') {\n            // canvas width - size to keep particles within canvas boundary\n            to = to || this.canvas.height - this.getSize('y', ctx);\n        } else {\n            throw new Error('Illegal Axis!');\n        }\n\n        let x = this.getRandomInt(from, to);\n        return x;\n    }\n\n    genRandomSize = (type = 'circle') => {\n        let size;\n        if (type === 'circle') {\n            size = { radius: this.getRandomInt(this.minSize, this.maxSize) };\n        } else {\n            size = {\n                width: this.getRandomInt(this.minSize, this.maxSize),\n                height: this.getRandomInt(this.minSize, this.maxSize)\n            };\n            if (type === 'square') {\n                size.width = size.height;\n            }\n        }\n\n        return size;\n    }\n\n    getRandomFloat = (min, max) => {\n        return Math.random() * (max - min) + min;\n    }\n\n    getRandomInt = (min, max) => {\n        return Math.floor(Math.random() * (max - min + 1) + min);\n    }\n\n    getSize = (axis, particle) => {\n        const object = typeof particle === 'object' ? particle : this;\n        let dimension = axis === 'x' ? 'width' : 'height';\n        if (particle.shape === 'circle') {\n            dimension = 'radius';\n        }\n        return parseInt(object.size[dimension]);\n    }\n\n    parseSize = (size, ctx) => {\n        let trueSize = size;\n        const obj = ctx || this;\n        if (typeof size !== 'object') {\n            trueSize = obj.shape === 'circle' ? { radius: size } : { width: size, height: size };\n        }\n        return trueSize;\n    }\n}\n","const aux = (props) => props.children;\n\nexport default aux;","import React, { Component } from 'react';\nimport Particles from './Particles';\nimport PropTypes from 'prop-types';\nimport Aux from '../Aux/Aux';\n\nconst sizePropType = PropTypes.oneOf([\n    {width: PropTypes.number.isRequired, height: PropTypes.number},\n    {radius: PropTypes.number.isRequired},\n    PropTypes.number\n]);\n\nconst shapePropType = PropTypes.shape({\n    type: PropTypes.oneOf(['image', 'rectangle', 'square', 'circle']).isRequired,\n    src: PropTypes.string,\n    size: sizePropType,\n    color: PropTypes.string,\n    to: PropTypes.shape({\n        x: PropTypes.number,\n        y: PropTypes.number,\n        size: sizePropType,\n        duration: PropTypes.number,\n        speed: PropTypes.number\n    })\n});\n\nexport default class Canvas extends Component {\n    static propTypes = {\n        options: PropTypes.shape({\n            maxParticles: PropTypes.number,\n            color: PropTypes.string,\n            colors: PropTypes.arrayOf(PropTypes.string),\n            shape: PropTypes.oneOfType([shapePropType, PropTypes.string]),\n            shapes: PropTypes.arrayOf(\n                PropTypes.oneOfType([shapePropType, PropTypes.string])\n            ),\n            minSize: PropTypes.number,\n            maxSize: PropTypes.number,\n            size: PropTypes.number,\n            minSpeed: PropTypes.number,\n            maxSpeed: PropTypes.number,\n            alpha: PropTypes.number,\n            frameRate: PropTypes.number,\n            duration: PropTypes.number,\n            precision: PropTypes.number,\n            debugOptions: PropTypes.shape({\n                enabled: PropTypes.bool.isRequired,\n                attachAllParticles: PropTypes.bool,\n                attachSingleParticles: PropTypes.bool\n            })\n        }),\n        handler: (props, propName, componentName) => {\n            if (props.handler === null || props.handler === undefined) {\n                return null;\n            }\n\n            if (!props.handler.hasOwnProperty('animate') && typeof props.handler.animate !== 'function') {\n                return new Error(`${propName} must have an 'animate' method in ${componentName}.`);\n            }\n            if (!props.handler.hasOwnProperty('draw') && typeof props.handler.draw !== 'function') {\n                return new Error(`${propName} must have an 'draw' method in ${componentName}.`);\n            }\n\n            return null;\n        },\n        className: PropTypes.string,\n        style: PropTypes.object\n    }\n\n    state = {\n        debug: null\n    }\n    handler = null;\n    debugInterval = null;\n\n    constructor(props) {\n        super(props);\n        this.handler = props.handler || Particles;\n    }\n\n    componentDidMount() {\n        window.addEventListener('resize', () => {\n            if (this.canvas) {\n                this.canvasSizing(this.canvas);\n            }\n        });\n\n        this.canvasSizing(this.canvas);\n        if (this.particles !== null && typeof this.particles.debug === 'object') {\n            this.debugInterval = setInterval(() => {\n                window.test = this.particles.debug;\n                const debug = Object.assign({}, this.particles.debug);\n                this.setState({ debug: debug });\n            }, 1000);\n        }\n    }\n\n    componentWillUnmount() {\n        window.removeEventListener('resize', () => {\n            this.canvasSizing(this.canvas);\n        });\n    }\n\n    canvasSizing = (canvas) => {\n        window.can = canvas;\n        const wWidth = canvas.parentElement.clientWidth;\n        const wHeight = canvas.parentElement.clientHeight;\n\n        const scale = window.devicePixelRatio;\n\n        canvas.style.width = wWidth + 'px';\n        canvas.style.height = wHeight + 'px';\n\n        canvas.width = scale * wWidth;\n        canvas.height = scale * wHeight;\n\n        if (this.particles !== null && typeof this.particles === 'object') {\n            this.particles.clear();\n            delete this.particles;\n        }\n\n        this.animate();\n    }\n\n    animate = () => {\n        let options = this.props.options;\n        let Handler = this.handler;\n        this.particles = new Handler(this.canvas, options);\n        this.particles.animate();\n    };\n\n    render() {\n        let debugElement = null;\n        if (this.state.debug !== null && typeof this.state.debug === 'object' && this.state.debug.frameRate !== null) {\n            this.canvas.parentElement.style.position = 'relative';\n            debugElement = (<div style={{\n                position: 'absolute',\n                top: 0,\n                right: 0,\n                fontSize: '14px',\n                padding: '10px',\n                color: 'white',\n                backgroundColor: 'rgba(0,0,0,0.7)'\n            }}>{this.state.debug.frameRate} <i>fps</i></div>);\n        }\n\n        return (\n            <Aux>\n                <canvas className={this.props.className} style={this.props.style} ref={canvas => {\n                    this.canvas = canvas;\n                }} />\n                {debugElement}\n            </Aux>\n        );\n    }\n}\n"]},"metadata":{},"sourceType":"module"}